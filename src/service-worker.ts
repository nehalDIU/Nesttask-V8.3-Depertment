// Define WindowClient and Client interfaces if not available in TypeScript env
// These type definitions match the standard Web API interfaces
interface WindowClient {
  focused: boolean;
  visibilityState: string;
  url: string;
  focus(): Promise<WindowClient>;
  navigate(url: string): Promise<WindowClient>;
  postMessage(message: any): void;
}

interface Client {
  id: string;
  type: string;
  url: string;
  postMessage(message: any): void;
}

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { registerRoute, NavigationRoute, Route } from 'workbox-routing';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { ExpirationPlugin } from 'workbox-expiration';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { warmStrategyCache } from 'workbox-recipes';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { BackgroundSyncPlugin } from 'workbox-background-sync';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { Queue } from 'workbox-background-sync';

// Cache names
const CACHE_NAME = 'nesttask-v3';
const ADMIN_CACHE_NAME = 'nesttask-admin-v1';
const METADATA_CACHE_NAME = 'sw-metadata';
const OFFLINE_URL = '/offline.html';

// Track service worker activity
let lastActivityTime = Date.now();

// Clean up outdated caches
cleanupOutdatedCaches();

// Precache all assets generated by your build process
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
precacheAndRoute(self.__WB_MANIFEST);

// Define URLs to preload/warm up cache - only essential UI assets
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
  '/offline.html',
  // Core app routes
  '/home',
  '/upcoming',
  '/search',
  '/routine',
  '/courses',
  '/profile',
  // Admin routes
  '/super-admin',
  '/super-admin/dashboard'
];

// Routes that should never be cached
const NEVER_CACHE_ROUTES = [
  '/auth',
  '/login',
  '/signup',
  '/reset-password'
];

// Admin routes that need special handling
const ADMIN_ROUTES = [
  '/super-admin',
  '/super-admin/dashboard',
  '/super-admin/settings'
];

// Add a utility function to safely check if a URL can be cached
function isValidCacheURL(url: string): boolean {
  try {
    const urlObj = new URL(url);
    const validProtocols = ['http:', 'https:'];
    if (!validProtocols.includes(urlObj.protocol)) {
      return false;
    }
    
    // Skip Supabase API requests
    if (urlObj.hostname.includes('supabase.co')) {
      return false;
    }
    
    // Skip Vercel Analytics
    if (urlObj.pathname.includes('_vercel/insights')) {
      return false;
    }
    
    // Check if the URL is a never-cache route
    const isNeverCacheRoute = NEVER_CACHE_ROUTES.some(route => 
      urlObj.pathname === route || urlObj.pathname.startsWith(`${route}/`)
    );
    
    if (isNeverCacheRoute) {
      return false;
    }
    
    return true;
  } catch (e) {
    console.error('Invalid URL:', url, e);
    return false;
  }
}

// Update activity timestamp for service worker
function updateActivityTimestamp() {
  lastActivityTime = Date.now();
  // Store the timestamp in cache to persist across service worker restarts
  if ('caches' in self) {
    caches.open(METADATA_CACHE_NAME).then(cache => {
      cache.put('lastActivityTime', new Response(JSON.stringify({ timestamp: lastActivityTime })));
    }).catch(err => {
      console.error('Error storing activity timestamp:', err);
    });
  }
}

// Check if the service worker has been inactive for too long
async function checkServiceWorkerInactivity() {
  try {
    if ('caches' in self) {
      const cache = await caches.open(METADATA_CACHE_NAME);
      const response = await cache.match('lastActivityTime');
      
      if (response) {
        const data = await response.json();
        const inactiveTime = Date.now() - data.timestamp;
        
        // If inactive for more than 45 minutes, update to keep alive
        if (inactiveTime > 45 * 60 * 1000) {
          console.log('Service worker has been inactive for too long. Refreshing timestamp.');
          updateActivityTimestamp();
        }
      }
    }
  } catch (e) {
    console.error('Error checking inactivity:', e);
  }
}

// Cache critical static assets with a Cache First strategy
const staticAssetsStrategy = new CacheFirst({
  cacheName: CACHE_NAME,
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
    new ExpirationPlugin({
      maxEntries: 100,
      maxAgeSeconds: 24 * 60 * 60, // 1 day
      purgeOnQuotaError: true
    }),
  ],
});

// Warm up the cache with critical assets
warmStrategyCache({
  urls: STATIC_ASSETS,
  strategy: staticAssetsStrategy
});

// Cache images with a Cache First strategy - only essential UI images
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    if (!isValidCacheURL(url.href)) {
      return false;
    }
    // Only cache essential UI images
    return request.destination === 'image' && 
           (url.pathname.includes('/icons/') || 
            url.pathname.includes('/images/ui/'));
  },
  new CacheFirst({
    cacheName: 'essential-images-v3',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache CSS and JavaScript with a Network First strategy
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    if (!isValidCacheURL(url.href)) {
      return false;
    }
    return request.destination === 'script' ||
           request.destination === 'style';
  },
  new NetworkFirst({
    cacheName: 'static-resources-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true
      }),
    ],
  })
);

// Optimized caching for fonts
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ request, url }: { request: any, url: any }) => {
    if (!isValidCacheURL(url.href)) {
      return false;
    }
    return request.destination === 'font' || 
           url.origin.includes('fonts.googleapis.com') ||
           url.origin.includes('fonts.gstatic.com');
  },
  new CacheFirst({
    cacheName: 'fonts-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true
      }),
    ],
  })
);

// Network Only for all API routes - never cache API responses
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    if (!isValidCacheURL(url.href)) {
      return false;
    }
    
    // Match all API endpoints - never cache them
    return url.pathname.includes('/api/') || 
           url.pathname.includes('/rest/') ||
           url.pathname.includes('/supabase/');
  },
  new NetworkOnly()
);

// Special handling for admin routes
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    if (!isValidCacheURL(url.href)) {
      return false;
    }
    
    // Check if this is an admin route
    return ADMIN_ROUTES.some(route => 
      url.pathname === route || url.pathname.startsWith(`${route}/`)
    );
  },
  new NetworkFirst({
    cacheName: ADMIN_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60, // 1 hour
        purgeOnQuotaError: true
      })
    ]
  })
);

// Enhanced caching for critical pages
registerRoute(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ({ url }: { url: any }) => {
    if (!isValidCacheURL(url.href)) {
      return false;
    }
    
    // Cache main app routes
    return url.pathname === '/' || 
           url.pathname === '/upcoming' || 
           url.pathname === '/search' ||
           url.pathname === '/routine' || 
           url.pathname === '/home' ||
           url.pathname === '/courses' ||
           url.pathname === '/profile';
  },
  new NetworkFirst({
    cacheName: 'app-pages-v3',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60, // 1 hour
        purgeOnQuotaError: true
      })
    ]
  })
);

// Create a separate NavigationRoute with its own NetworkFirst strategy
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const navigationRoute = new NavigationRoute(new NetworkFirst({
  cacheName: 'navigations-v3',
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
    new ExpirationPlugin({
      maxEntries: 10,
      maxAgeSeconds: 60 * 60, // 1 hour
      purgeOnQuotaError: true
    })
  ]
}), {
  // Disable caching for API routes and admin pages
  denylist: [/\/api\//, /\/admin\//, /\/rest\//, ...NEVER_CACHE_ROUTES.map(route => new RegExp(route))]
});

// Register the navigation route
registerRoute(navigationRoute);

// Create task queue for background sync
const taskSyncQueue = new Queue('taskQueue', {
  maxRetentionTime: 7 * 24 * 60, // Retry for up to 7 days (in minutes)
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for task operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'task'
          });
        }
      } catch (error) {
        console.error('Sync failed for task:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Create routine queue for background sync
const routineSyncQueue = new Queue('routineQueue', {
  maxRetentionTime: 7 * 24 * 60, // Retry for up to 7 days
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for routine operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'routine'
          });
        }
      } catch (error) {
        console.error('Sync failed for routine:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Create course/teacher queue for background sync
const courseTeacherSyncQueue = new Queue('courseTeacherQueue', {
  maxRetentionTime: 7 * 24 * 60, // Retry for up to 7 days
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request.clone());
        console.log('Sync successful for course/teacher operation');
        
        // Notify the client that sync is complete
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const clients = await (self as any).clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            category: 'courseTeacher'
          });
        }
      } catch (error) {
        console.error('Sync failed for course/teacher:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
});

// Create background sync plugins
const taskBgSyncPlugin = new BackgroundSyncPlugin('taskQueue', {
  maxRetentionTime: 7 * 24 * 60 // Retry for up to 7 days
});

const routineBgSyncPlugin = new BackgroundSyncPlugin('routineQueue', {
  maxRetentionTime: 7 * 24 * 60 // Retry for up to 7 days
});

const courseTeacherBgSyncPlugin = new BackgroundSyncPlugin('courseTeacherQueue', {
  maxRetentionTime: 7 * 24 * 60 // Retry for up to 7 days
});

// Handle sync events directly
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('sync', (event: any) => {
  console.log('Sync event received:', event.tag);
  updateActivityTimestamp();
  
  if (event.tag === 'taskSync') {
    event.waitUntil(taskSyncQueue.replayRequests());
  } else if (event.tag === 'routineSync') {
    event.waitUntil(routineSyncQueue.replayRequests());
  } else if (event.tag === 'courseTeacherSync') {
    event.waitUntil(courseTeacherSyncQueue.replayRequests());
  }
});

// Add a global error handler to catch unexpected errors
self.addEventListener('error', (event) => {
  console.error('Service Worker error:', event.error);
  updateActivityTimestamp();
});

// Add an unhandled rejection handler
self.addEventListener('unhandledrejection', (event) => {
  console.error('Service Worker unhandled rejection:', event.reason);
  updateActivityTimestamp();
});

// Push notification handler
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('push', (event: any) => {
  updateActivityTimestamp();
  
  if (!event.data) return;

  try {
    const data = event.data.json();
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge.png',
      vibrate: [100, 50, 100],
      data: {
        url: data.data?.url || '/',
        taskId: data.data?.taskId,
        type: data.data?.type
      },
      actions: data.actions || [
        {
          action: 'open',
          title: 'Open',
          icon: '/icons/icon-192x192.png'
        }
      ],
      tag: data.tag || 'default',
      renotify: true,
      requireInteraction: true
    };

    event.waitUntil(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (self as any).registration.showNotification(data.title, options)
    );
  } catch (error) {
    console.error('Error handling push notification:', error);
  }
});

// Notification click handler
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('notificationclick', (event: any) => {
  event.notification.close();
  updateActivityTimestamp();

  if (event.action === 'close') return;

  const urlToOpen = event.notification.data?.url || '/';
  const taskId = event.notification.data?.taskId;
  const notificationType = event.notification.data?.type;

  event.waitUntil(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (self as any).clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((windowClients: WindowClient[]) => {
        // Check if there is already a window/tab open with the target URL
        const hadWindowToFocus = windowClients.some((windowClient) => {
          if (windowClient.url === urlToOpen) {
            // Focus if already open
            windowClient.focus();
            // Send message to client to handle the notification action
            if (taskId) {
              windowClient.postMessage({
                type: 'NOTIFICATION_CLICK',
                taskId: taskId,
                notificationType: notificationType
              });
            }
            return true;
          }
          return false;
        });

        // If no window with target URL, open a new one
        if (!hadWindowToFocus) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return (self as any).clients.openWindow(urlToOpen).then((windowClient: WindowClient) => {
            // Send message to newly opened client after a short delay
            // to ensure the app has loaded
            if (windowClient && taskId) {
              setTimeout(() => {
                windowClient.postMessage({
                  type: 'NOTIFICATION_CLICK',
                  taskId: taskId,
                  notificationType: notificationType
                });
              }, 1000);
            }
          });
        }
      })
  );
});

// Add a message handler for keep-alive pings and other messages
// eslint-disable-next-line @typescript-eslint/no-explicit-any
self.addEventListener('message', (event: any) => {
  // Update activity timestamp on any message
  updateActivityTimestamp();
  
  if (event.data && event.data.type === 'KEEP_ALIVE') {
    console.debug('Keep-alive ping received at', new Date(event.data.timestamp).toISOString());
    
    // Respond to the keep-alive to confirm service worker is active
    if (event.source) {
      event.source.postMessage({
        type: 'KEEP_ALIVE_RESPONSE',
        timestamp: Date.now()
      });
    }
    
    // Reset any internal timers to keep the service worker active
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    self.registration.active?.postMessage({
      type: 'INTERNAL_KEEP_ALIVE'
    });
  } else if (event.data && event.data.type === 'SYNC_NOW') {
    console.log('SYNC_NOW message received, attempting immediate sync');
    
    // Try to perform sync for all queues
    Promise.allSettled([
      taskSyncQueue.replayRequests(),
      routineSyncQueue.replayRequests(),
      courseTeacherSyncQueue.replayRequests()
    ]).then(results => {
      console.log('Sync attempts completed:', results);
      
      // Notify client that sync was attempted
      if (event.source) {
        event.source.postMessage({
          type: 'SYNC_NOW_COMPLETED',
          results: results.map(r => r.status)
        });
      }
    });
  } else if (event.data && event.data.type === 'CLEAR_ALL_CACHES') {
    console.log('CLEAR_ALL_CACHES message received, clearing all caches');
    
    // Clear all caches except metadata and admin cache
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => cacheName !== METADATA_CACHE_NAME && cacheName !== ADMIN_CACHE_NAME)
          .map((cacheName) => caches.delete(cacheName))
      );
    }).then(() => {
      // Recreate the main cache with static assets
      return caches.open(CACHE_NAME).then((cache) => {
        return cache.addAll(STATIC_ASSETS);
      });
    }).then(() => {
      console.log('All caches cleared and static assets reloaded (admin cache preserved)');
      
      // Notify all clients
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (self as any).clients.matchAll().then((clients: Client[]) => {
        clients.forEach(client => {
          client.postMessage({
            type: 'CACHES_CLEARED',
            timestamp: Date.now()
          });
        });
      });
      
      // If this message had a source, respond to it
      if (event.source) {
        event.source.postMessage({
          type: 'CACHES_CLEARED',
          timestamp: Date.now()
        });
      }
    });
  } else if (event.data && event.data.type === 'AUTH_STATE_CHANGED') {
    // Handle auth state changes (login/logout)
    console.log('Auth state changed:', event.data.event);
    
    // Clear navigation cache to ensure fresh content after auth state changes
    caches.open(CACHE_NAME).then((cache) => {
      const authRelatedUrls = [
        '/',
        '/index.html',
        '/home',
        '/profile',
        '/settings',
        '/admin',
        '/super-admin',
        '/super-admin/dashboard'
      ];
      
      // Delete these cached entries so they'll be fetched fresh
      Promise.all(authRelatedUrls.map(url => 
        cache.delete(new Request(url))
      )).then(() => {
        console.log('Cleared auth-related caches');
        
        // Notify clients that caches were cleared
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (self as any).clients.matchAll().then((clients: Client[]) => {
          clients.forEach(client => {
            client.postMessage({
              type: 'AUTH_CACHES_CLEARED',
              timestamp: Date.now()
            });
          });
        });
      });
    });
  } else if (event.data && event.data.type === 'HEALTH_CHECK') {
    console.log('Health check request received');
    
    // Respond to confirm the service worker is healthy
    if (event.source) {
      event.source.postMessage({
        type: 'HEALTH_CHECK_RESPONSE',
        timestamp: Date.now(),
        status: 'healthy',
        lastActivity: lastActivityTime
      });
    }
  } else if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('Skip waiting requested, activating service worker immediately');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (self as any).skipWaiting();
  } else if (event.data && event.data.type === 'CLAIM_CLIENTS') {
    console.log('Claim clients requested, claiming all clients');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (self as any).clients.claim();
    
    // Notify clients that they've been claimed
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (self as any).clients.matchAll().then((clients: Client[]) => {
      clients.forEach(client => {
        client.postMessage({
          type: 'CLAIMED_BY_SERVICE_WORKER',
          timestamp: Date.now()
        });
      });
    });
  }
});

// Set up a periodic ping to keep the service worker alive
setInterval(() => {
  updateActivityTimestamp();
  console.debug('Self-ping to keep service worker alive at', new Date().toISOString());
}, 20 * 60 * 1000); // Ping every 20 minutes